# 42 Piscine — C00 Cheat Sheet (Darija)

> هدف هاد الورقة: تعطيك خلاصة سريعة + نقاط عميقة للأسئلة ديال الدفاع (بدون حلول). استعملها مع `cat -e` و `gcc -Wall -Wextra -Werror` فالتجارب.

---

## قواعد عامة (مختصرة)
- سُلِّم غير اللي طالبين: أسماء الملفات والمجلدات *بالضبط*.
- الطباعة مسموحة بــ `write` فقط.
- الكمبايل: `gcc -Wall -Wextra -Werror`؛ أي warning = error.
- راقب المخرجات حرف بحرف: `./a.out | cat -e` باش تشوف الفراغات والـ newline.

### `write` (تذكير سريع)
```txt
write(fd, buffer_address, count)
fd=1 (stdout), fd=2 (stderr)
يرجع عدد البايتات المَطبوعة أو -1 فحالة خطأ.
```

### ASCII السريع
- Digits: `'0'..'9'` = 48..57
- Lowercase: `'a'..'z'` = 97..122
- Uppercase: `'A'..'Z'` = 65..90

### تحويلات مفيدة (بدون كود فعلي)
- digit → char: `digit + '0'`
- two-digit print idea: `tens = n/10`, `ones = n%10`، وكيخص التعامل مع leading zero.

---

## ex00 — ft_putchar
**خاصك تكون فاهم:**
- كيفاش `write(1, &c, 1)` كيطبع بايت واحد.
- `'a'`(char) و`"a"` (string)  الفرق بين .
- الفرق بين `'a'` (char) و `"a"` (string).

**أسئلة دفاع عميقة:**
- شنو هو file descriptor؟ 0/1/2؟ علاش stdout=1؟
- علاش كتحتاج `&c` (العنوان) ماشي `c`؟
- شنو نوع الإرجاع ديال `write` وشنو كتدير إلا فشل؟
- signedness ديال `char` وتأثيره (implementation-defined).

**اختبار سريع:**
- جرّب طباعة أحرف: مسافة، `\n`، رموز، وأحرف خارج ASCII الأساسي.

---

## ex01 — ft_print_alphabet & ex02 — reverse
**خاصك تكون فاهم:**
- التكرار عبر ASCII متتابع من `'a'` لـ `'z'` أو العكس.
- ما كاين لا newline لا space إلا إذا طُلب.

**أسئلة دفاع عميقة:**
- واش آمن تعتمد على تتابع ASCII للحروف؟ (عملياً فبيئة 42 نعم)؛ المعايير والـ locales.
- recursion vs loop: واش تقدر فكرياً تديرها recursive؟ فين الـ base-case؟

**اختبارات:**
- تحقق من عدم وجود محارف زائدة: `| cat -e`.

---

## ex03 — ft_print_numbers
**خاصك تكون فاهم:**
- الفرق بين `0` (int) و`'0'` (char) وشنو كيوقع إلا جمعتيهم.
- ترتيب الأرقام `'0'..'9'` بدون newline.

**أسئلة دفاع عميقة:**
- ASCII arithmetic: علاش `'0'+3` = `'3'`؟
- شنو الفرق بين طباعة 10 كـ رقم vs `'1'` و`'0'` كحرفين؟

---

## ex04 — ft_is_negative
**خاصك تكون فاهم:**
- شروط `if/else` بسيطة: `N` إذا n<0، و `P` إذا n>=0.
- حالة 0 كتدخل مع `P`.

**أسئلة دفاع عميقة:**
- حدود النوع `int`: شنو أقل/أقصى قيمة؟ علاش مفيدين حتى هنا؟
- الفرق بين `<0` و `<=0` فالسلوك المطلوب.

---

## ex05 — ft_print_comb (3 أرقام مختلفة مرتبة)
**خاصك تكون فاهم:**
- توافيق `i<j<k` من 0..9 (بدون تكرار).
- تنسيق الإخراج: ثلاث حروف للأرقام، وبين التركيبات `, ` (فاصلة ومسافة) *بدون فاصلة أخيرة*.

**أسئلة دفاع عميقة:**
- عدد التركيبات C(10,3)=120 (منطق التوافيق).
- lexico order: علاش 789 كافي و987 زائد؟
- تقنيات منع الفاصلة الأخيرة: كيف تعرف “آخر عنصر” منطقيًا؟

**اختبارات:**
- أول عناصر: `012, 013, ...` وآخرها `789` بدون لاحقة.

---

## ex06 — ft_print_comb2 (أزواج من 00..99)
**خاصك تكون فاهم:**
- طباعة رقمين بــ leading zero دائمًا (00..99).
- كل زوجين `ab cd` بحيث `ab < cd` فقط؛ بين الأزواج `, ` والمسافة وسط الزوجين موجودة.

**أسئلة دفاع عميقة:**
- صياغة two-digit print: استخراج tens/ones كأحرف.
- علاش `01 00` غير مقبول؟ الشروط المنطقية للمقارنة.
- الأداء: شحال من تكرار؟ علاش nested loops كافية هنا؟

**اختبارات:**
- بدايات: `00 01, 00 02, ...`
- نهايات: `98 99` بلا فاصلة أخيرة.

---

## ex07 — ft_putnbr
**خاصك تكون فاهم:**
- كيفاش تطبع أي `int` بدون `printf`: استعمال القسمة/الباقي لاستخراج الأرقام.
- التعامل مع الإشارة السالبة.
- الحالة الخاصة `INT_MIN`: علاش `-INT_MIN` كيعمل overflow؟ وكيف نتفاداه (فكريًا: استعمل نوع أوسع أو special-case).

**أسئلة دفاع عميقة:**
- سلوك القسمة والباقي مع الأعداد السالبة في C (تُقرب للصفر).
- recursion depth: أقصى 10 مكالمات (عدد الأرقام).
- الفرق بين التحويل لـ `long` قبل المعالجة ولماذا مفيد.

**اختبارات:**
- `0`, أعداد صغيرة موجبة/سالبة، `INT_MIN`, `INT_MAX`.

---

## ex08 — ft_print_combn (n من 1..9)
**خاصك تكون فاهم:**
- تمثيل الحالة بمصفوفة `a[0..n-1]` متزايدة strictly.
- قاعدة الإنهاء: آخر تكوين هو `[10-n, ..., 9]`.
- “ترقية” من اليمين (carry): إلا زدت خانة، عبّي اللي على يمينها بشكل متتابع.
- التنسيق: `, ` بين التركيبات، ولا فاصلة في الأخير.

**أسئلة دفاع عميقة:**
- علاش strictly increasing؟ (باش تمنع التكرار والانعكاس).
- التعقيد: عدد التركيبات C(10, n)؛ واش recursion ولا iteration أفضل ولماذا؟
- كيف تكتشف “آخر عنصر” بدون مقارنة نصية.

**اختبارات:**
- n=1 → 0..9
- n=2 → 01, 02, ..., 89
- n=9 → 012345678, 012345679, ..., 123456789 (بدون فاصلة أخيرة).

---

## أدوات اختبار عملية
- كومبايل: `gcc -Wall -Wextra -Werror file.c && ./a.out | cat -e`
- قارن نتيجة بملف متوقع: `diff -u expected.txt <(./a.out)`
- اختبر الحدود: `INT_MIN/INT_MAX`, leading zeros, آخر عنصر بدون فاصلة.

---

## فخاخ متكررة
- فاصلة/مسافة/ newline زايدة أو ناقصة.
- نسيان INT_MIN فـ `putnbr`.
- طباعة بصيغ مختلفة عن المطلوب.
- أرقام غير مصفرة بــ 0 (leading zero) فـ comb2.

---

**ملاحظة**: هاد الورقة مرجع سريع؛ راجع الكونسابتس بعمق (FDs, ASCII, recursion, integer limits) ودرّب على صياغة “آخر عنصر” باش ماتطبعش الفاصلة الأخيرة.
